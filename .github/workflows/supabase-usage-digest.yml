name: Supabase Usage Digest (Gmail, with overall %)

on:
  schedule:
    - cron: "0 3 * * *" # 03:00 UTC = 09:30 MMT
  workflow_dispatch:

jobs:
  digest:
    runs-on: ubuntu-latest
    env:
      SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
      SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}

      # Gmail API
      GMAIL_CLIENT_ID: ${{ secrets.GMAIL_CLIENT_ID }}
      GMAIL_CLIENT_SECRET: ${{ secrets.GMAIL_CLIENT_SECRET }}
      GMAIL_REFRESH_TOKEN: ${{ secrets.GMAIL_REFRESH_TOKEN }}
      GMAIL_FROM: ${{ secrets.GMAIL_FROM }}
      GMAIL_TO: ${{ secrets.GMAIL_TO }}

      # Free caps (override via Secrets if needed)
      DB_FREE_MB: ${{ secrets.DB_FREE_MB }}
      ST_FREE_MB: ${{ secrets.ST_FREE_MB }}
      MONTHLY_EGRESS_FREE_MB: ${{ secrets.MONTHLY_EGRESS_FREE_MB }}
      # Retention for usage_snapshots (days)
      USAGE_SNAPSHOT_RETENTION_DAYS: ${{ secrets.USAGE_SNAPSHOT_RETENTION_DAYS }}

      # Realtime free caps (optional overrides; defaults set in steps)
      REALTIME_FREE_MESSAGES: ${{ secrets.REALTIME_FREE_MESSAGES }}
      REALTIME_FREE_CONNECTIONS: ${{ secrets.REALTIME_FREE_CONNECTIONS }}

    steps:
      - name: Install tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: (Optional) Insert 1 snapshot/day
        run: |
          curl -sS -X POST \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Content-Type: application/json" \
            "$SUPABASE_URL/rest/v1/rpc/take_usage_snapshot" >/dev/null || true

      - name: Prune old usage_snapshots
        run: |
          set -e
          DAYS="${USAGE_SNAPSHOT_RETENTION_DAYS:-90}"
          # Use ISO8601 UTC timestamp for precise comparison
          CUTOFF_ISO=$(date -u -d "-$DAYS days" +"%Y-%m-%dT%H:%M:%SZ")
          echo "Pruning usage_snapshots older than $DAYS days (before $CUTOFF_ISO)"

          # Delete rows older than cutoff; ignore error if table doesn't exist
          curl -sS -X DELETE \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Prefer: count=exact" \
            "$SUPABASE_URL/rest/v1/usage_snapshots?taken_at=lt.$CUTOFF_ISO" >/dev/null || true

      - name: Fetch DB/Storage (MB)
        id: fetch_ds
        run: |
          set -e
          DB=$(curl -sS -X POST \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Content-Type: application/json" \
            "$SUPABASE_URL/rest/v1/rpc/get_db_size_mb" | jq -r '.')
          ST=$(curl -sS -X POST \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Content-Type: application/json" \
            "$SUPABASE_URL/rest/v1/rpc/get_storage_total_mb" | jq -r '.')
          echo "db_mb=$DB" >> "$GITHUB_OUTPUT"
          echo "st_mb=$ST" >> "$GITHUB_OUTPUT"

      - name: Fetch Egress MTD (optional)
        id: fetch_eg
        run: |
          set -e
          MONTH_START=$(date -u +"%Y-%m-01")
          NEXT_MONTH_START=$(date -u -d "$MONTH_START +1 month" +%F)
          HTTP=$(curl -sS -w "%{http_code}" -o eg.json \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            "$SUPABASE_URL/rest/v1/egress_daily_totals?select=bytes&day=gte.$MONTH_START&day=lt.$NEXT_MONTH_START")
          if [ "$HTTP" = "200" ]; then
            BYTES=$(jq -r '[.[].bytes] | add // 0' eg.json)
            MB=$(awk "BEGIN {printf \"%.1f\", ($BYTES/1024/1024)}")
            echo "egress_mtd_mb=$MB" >> "$GITHUB_OUTPUT"
          else
            echo "egress_mtd_mb=N/A" >> "$GITHUB_OUTPUT"
          fi

      # ===== Realtime: messages =====
      - name: Fetch Realtime messages counter (Prometheus)
        id: rt_counter
        run: |
          set -euo pipefail
          RAW=$(curl -sS --user "service_role:${SERVICE_ROLE_KEY}" \
            "$SUPABASE_URL/customer/v1/privileged/metrics" || true)

          # 複数のメトリクス名に対応して合算
          RT=$(printf "%s\n" "$RAW" \
            | awk '$1 !~ /^#/ && ($1 ~ /(realtime.*(messages|events).*(total|count)|channel.*events.*total)/){s+=$2} END{print s+0}')

          echo "counter=$RT" >> "$GITHUB_OUTPUT"

      - name: Ensure month-start snapshot for Realtime counter
        id: rt_baseline
        run: |
          set -Eeuo pipefail

          MONTH_START_DATE=$(date -u +"%Y-%m-01")
          MONTH_START="${MONTH_START_DATE}T00:00:00Z"

          # 前提: realtime_msgs_counter は既に存在

          # 月初以降の baseline を取得（HTTPコードとJSON型を検査）
          HTTP=$(curl -sS -w "%{http_code}" -o rt_base.json \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Accept: application/json" \
            "$SUPABASE_URL/rest/v1/usage_snapshots?select=realtime_msgs_counter,taken_at&taken_at=gte.$MONTH_START&realtime_msgs_counter=not.is.null&order=taken_at.asc&limit=1")

          if [ "$HTTP" != "200" ]; then
            BASE=""
            BASE_AT=""
          else
            BASE=$(jq -r 'if type=="array" and length>0 then .[0].realtime_msgs_counter else empty end' rt_base.json)
            BASE_AT=$(jq -r 'if type=="array" and length>0 then .[0].taken_at else empty end' rt_base.json)
          fi

          if [ -z "${BASE:-}" ]; then
            NOWISO=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            CUR="${{ steps.rt_counter.outputs.counter }}"
            curl -sS -X POST \
              -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
              -H "Prefer: resolution=merge-duplicates" \
              -H "Accept: application/json" -H "Content-Type: application/json" \
              "$SUPABASE_URL/rest/v1/usage_snapshots" \
              -d "{\"taken_at\":\"$NOWISO\",\"realtime_msgs_counter\":${CUR:-0}}" >/dev/null || true
            BASE="${CUR:-0}"
            BASE_AT="$NOWISO"
          fi

          echo "baseline=$BASE" >> "$GITHUB_OUTPUT"
          echo "base_at=${BASE_AT:-$MONTH_START}" >> "$GITHUB_OUTPUT"

      - name: Compute Realtime MTD & percent
        id: rt_mtd
        env:
          COUNTER: ${{ steps.rt_counter.outputs.counter }}
          BASELINE: ${{ steps.rt_baseline.outputs.baseline }}
        run: |
          set -euo pipefail
          REALTIME_FREE_MESSAGES="${REALTIME_FREE_MESSAGES:-2000000}"

          if [ -z "${COUNTER:-}" ] || [ -z "${BASELINE:-}" ]; then
            echo "mtd=N/A" >> "$GITHUB_OUTPUT"
            echo "pct=N/A" >> "$GITHUB_OUTPUT"
          else
            MTD=$(( ${COUNTER%.*} - ${BASELINE%.*} ))
            if [ $MTD -lt 0 ]; then MTD=0; fi
            PCT=$(awk "BEGIN {if ($REALTIME_FREE_MESSAGES==0) print 0; else printf \"%.1f\", ($MTD/$REALTIME_FREE_MESSAGES)*100}")
            echo "mtd=$MTD" >> "$GITHUB_OUTPUT"
            echo "pct=$PCT" >> "$GITHUB_OUTPUT"
          fi

      # ===== Realtime: concurrent connections =====
      - name: Fetch current Realtime concurrent connections
        id: rt_conn
        run: |
          set -euo pipefail
          RAW=$(curl -sS --user "service_role:${SERVICE_ROLE_KEY}" \
            "$SUPABASE_URL/customer/v1/privileged/metrics" || true)

          # 複数候補から最大値を採用
          CONN=$(printf "%s\n" "$RAW" \
            | awk '$1 !~ /^#/ {if($1 ~ /realtime.*(client|connection).*connected/ || $1 ~ /realtime.*active.*connections/){if($2>m)m=$2}} END{print m+0}')

          echo "current=$CONN" >> "$GITHUB_OUTPUT"

      - name: Ensure column & update MTD peak for connections
        id: rt_conn_peak
        env:
          CURR: ${{ steps.rt_conn.outputs.current }}
        run: |
          set -Eeuo pipefail

          MONTH_START_DATE=$(date -u +"%Y-%m-01")
          MONTH_START="${MONTH_START_DATE}T00:00:00Z"

          # 前提: realtime_conn_peak と realtime_conn_obs は既に存在

          # 月内ピーク（従来ロジックを維持）
          HTTP=$(curl -sS -w "%{http_code}" -o rt_conn.json \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Accept: application/json" \
            "$SUPABASE_URL/rest/v1/usage_snapshots?select=realtime_conn_peak,taken_at&taken_at=gte.$MONTH_START&realtime_conn_peak=not.is.null&order=taken_at.desc&limit=1")

          if [ "$HTTP" != "200" ]; then
            PEAK=""
          else
            PEAK=$(jq -r 'if type=="array" and length>0 then .[0].realtime_conn_peak else empty end' rt_conn.json)
          fi

          CUR=${CURR%.*}
          if [ -z "${PEAK:-}" ]; then
            NEW_PEAK="${CUR:-0}"
          else
            if [ "${CUR:-0}" -gt "$PEAK" ]; then NEW_PEAK="${CUR:-0}"; else NEW_PEAK="$PEAK"; fi
          fi

          NOWISO=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

          # 変化があるときだけ MTDピークを記録
          if [ -z "${PEAK:-}" ] || [ "$NEW_PEAK" -ne "${PEAK:-0}" ]; then
            curl -sS -X POST \
              -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
              -H "Prefer: resolution=merge-duplicates" \
              -H "Accept: application/json" -H "Content-Type: application/json" \
              "$SUPABASE_URL/rest/v1/usage_snapshots" \
              -d "{\"taken_at\":\"$NOWISO\",\"realtime_conn_peak\":$NEW_PEAK}" >/dev/null || true
          fi

          # 観測値は毎回保存（24hピーク算出用）
          curl -sS -X POST \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Prefer: resolution=merge-duplicates" \
            -H "Accept: application/json" -H "Content-Type: application/json" \
            "$SUPABASE_URL/rest/v1/usage_snapshots" \
            -d "{\"taken_at\":\"$NOWISO\",\"realtime_conn_obs\":${CUR:-0}}" >/dev/null || true

          echo "peak=${NEW_PEAK:-$PEAK}" >> "$GITHUB_OUTPUT"

      - name: Compute Realtime concurrent connections 24h peak
        id: rt_conn_24h
        run: |
          set -Eeuo pipefail
          WINDOW_START=$(date -u -d "-24 hours" +"%Y-%m-%dT%H:%M:%SZ")

          HTTP=$(curl -sS -w "%{http_code}" -o rt_conn_obs.json \
            -H "apikey: $SERVICE_ROLE_KEY" -H "Authorization: Bearer $SERVICE_ROLE_KEY" \
            -H "Accept: application/json" \
            "$SUPABASE_URL/rest/v1/usage_snapshots?select=realtime_conn_obs&taken_at=gte.$WINDOW_START&realtime_conn_obs=not.is.null&order=taken_at.desc")

          if [ "$HTTP" != "200" ]; then
            PEAK24=""
          else
            PEAK24=$(jq -r 'if type=="array" and length>0 then [.[].realtime_conn_obs]|max else empty end' rt_conn_obs.json)
          fi

          echo "peak24=$PEAK24" >> "$GITHUB_OUTPUT"

      - name: Compute Realtime concurrent connections percent
        id: rt_conn_pct
        env:
          PEAK24: ${{ steps.rt_conn_24h.outputs.peak24 }}
        run: |
          set -euo pipefail
          REALTIME_FREE_CONNECTIONS="${REALTIME_FREE_CONNECTIONS:-200}"
          if [ -z "${PEAK24:-}" ]; then
            echo "pct=N/A" >> "$GITHUB_OUTPUT"
            echo "peak=0" >> "$GITHUB_OUTPUT"
          else
            PCT=$(awk "BEGIN {if ($REALTIME_FREE_CONNECTIONS==0) print 0; else printf \"%.1f\", ($PEAK24/$REALTIME_FREE_CONNECTIONS)*100}")
            echo "pct=$PCT" >> "$GITHUB_OUTPUT"
            echo "peak=$PEAK24" >> "$GITHUB_OUTPUT"
          fi

      # ===== メール送信 =====
      - name: Send Gmail digest (overall %)
        env:
          DB: ${{ steps.fetch_ds.outputs.db_mb }}
          ST: ${{ steps.fetch_ds.outputs.st_mb }}
          EGRESS_MTD_MB: ${{ steps.fetch_eg.outputs.egress_mtd_mb }}
          RT_MTD: ${{ steps.rt_mtd.outputs.mtd }}
          RT_PCT: ${{ steps.rt_mtd.outputs.pct }}
          RT_BASE_AT: ${{ steps.rt_baseline.outputs.base_at }}
          RT_CONN_PEAK_24H: ${{ steps.rt_conn_pct.outputs.peak }}
          RT_CONN_PCT: ${{ steps.rt_conn_pct.outputs.pct }}
          REALTIME_FREE_MESSAGES: ${{ secrets.REALTIME_FREE_MESSAGES }}
          REALTIME_FREE_CONNECTIONS: ${{ secrets.REALTIME_FREE_CONNECTIONS }}
        run: |
          set -Eeuo pipefail
          DB_FREE_MB="${DB_FREE_MB:-500}"
          ST_FREE_MB="${ST_FREE_MB:-1024}"
          MONTHLY_EGRESS_FREE_MB="${MONTHLY_EGRESS_FREE_MB:-5120}"  # 5GB
          REALTIME_FREE_MESSAGES="${REALTIME_FREE_MESSAGES:-2000000}"
          REALTIME_FREE_CONNECTIONS="${REALTIME_FREE_CONNECTIONS:-200}"

          PCT_DB=$(awk "BEGIN {if ($DB_FREE_MB==0) print 0; else printf \"%.1f\", ($DB/$DB_FREE_MB)*100}")
          PCT_ST=$(awk "BEGIN {if ($ST_FREE_MB==0) print 0; else printf \"%.1f\", ($ST/$ST_FREE_MB)*100}")

          if [[ "$EGRESS_MTD_MB" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
            PCT_EG=$(awk "BEGIN {if ($MONTHLY_EGRESS_FREE_MB==0) print 0; else printf \"%.1f\", ($EGRESS_MTD_MB/$MONTHLY_EGRESS_FREE_MB)*100}")
            EGRESS_LINE=$(printf "Egress (MTD): %s MB / %s MB  (%s%%)" "$EGRESS_MTD_MB" "$MONTHLY_EGRESS_FREE_MB" "$PCT_EG")
          else
            EGRESS_LINE="Egress (MTD): N/A  (enable self-measure or provide source)"
          fi

          ACCESS_TOKEN=$(curl -sS -X POST https://oauth2.googleapis.com/token \
            -H "Content-Type: application/x-www-form-urlencoded" \
            -d "client_id=$GMAIL_CLIENT_ID&client_secret=$GMAIL_CLIENT_SECRET&refresh_token=$GMAIL_REFRESH_TOKEN&grant_type=refresh_token" \
            | jq -r '.access_token')

          NOW_MMT=$(date -u -d "+6 hours 30 minutes" "+%Y-%m-%d %H:%M MMT")
          NOW_UTC=$(date -u "+%Y-%m-%d %H:%M UTC")
          MONTH_START_UTC=$(date -u -d "$(date -u +%Y-%m-01)" "+%Y-%m-%d 00:00 UTC")
          WINDOW_START_UTC=$(date -u -d "-24 hours" "+%Y-%m-%d %H:%M UTC")

          SUBJECT="[DAILY] Supabase usage summary (with periods)"

          BODY=$(printf \
            "Supabase daily usage (generated at %s / %s)\n\n" \
            "DB (snapshot at %s): %s MB / %s MB  (%s%%)\n" \
            "Storage (snapshot at %s): %s MB / %s MB  (%s%%)\n" \
            "Egress (MTD, %s → %s): %s MB / %s MB  (%s%%)\n" \
            "Realtime messages (MTD, baseline %s): %s / %s  (%s%%)\n" \
            "Realtime concurrent connections (24h peak, %s → %s): %s / %s  (%s%%)\n" \
            "$NOW_MMT" "$NOW_UTC" \
            "$NOW_UTC" "$DB" "$DB_FREE_MB" "$PCT_DB" \
            "$NOW_UTC" "$ST" "$ST_FREE_MB" "$PCT_ST" \
            "$MONTH_START_UTC" "$NOW_UTC" "$EGRESS_MTD_MB" "$MONTHLY_EGRESS_FREE_MB" "${PCT_EG:-N/A}" \
            "${RT_BASE_AT:-$MONTH_START_UTC}" "${RT_MTD:-N/A}" "$REALTIME_FREE_MESSAGES" "${RT_PCT:-N/A}" \
            "$WINDOW_START_UTC" "$NOW_UTC" "${RT_CONN_PEAK_24H:-N/A}" "$REALTIME_FREE_CONNECTIONS" "${RT_CONN_PCT:-N/A}" )

          MIME=$(printf "From: %s\nTo: %s\nSubject: %s\nContent-Type: text/plain; charset=UTF-8\n\n%s" "$GMAIL_FROM" "$GMAIL_TO" "$SUBJECT" "$BODY")
          RAW=$(printf "%s" "$MIME" | base64 -w0 | tr '+/' '-_' | tr -d '=')
          PAYLOAD=$(jq -n --arg raw "$RAW" '{raw:$raw}')

          curl -sS -X POST "https://gmail.googleapis.com/gmail/v1/users/me/messages/send" \
            -H "Authorization: Bearer $ACCESS_TOKEN" -H "Content-Type: application/json" \
            -d "$PAYLOAD" >/dev/null

          echo "Digest email sent."
